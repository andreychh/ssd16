% SPDX-FileCopyrightText: Copyright (c) 2021 Yegor Bugayenko
% SPDX-License-Identifier: MIT

\documentclass[nobrand,anonymous,nodate,nosecurity]{huawei}
\usepackage{href-ul}
\begin{document}

{\sffamily{\bfseries\Large Software System Design}\\
16-lectures course presented by \href{https://www.yegor256.com}{Yegor Bugayenko}\\
to 3rd-year BSc students of \href{https://innopolis.university/en/}{Innopolis University} in 2021,\\
and \href{https://www.youtube.com/playlist?list=PLaIsQH4uc08woJKRAA7mmjs9fU0jeKjjM}{video recorded}}

The entire set of slide decks is in \href{https://github.com/yegor256/ssd16}{yegor256/ssd16} GitHub repository.

\section*{Thinking Behind the Course}

\newpage
\textbf{The context in which the new course will be taught}:
There are 150 students on the course, one instructor, three teaching assistants,
16 lectures, 16 labs, 90 minutes per each lecture, presented on-site in the
University, streamed online via Zoom, and later published on YouTube.

\newpage
\textbf{The context in which the new syllabus will be used}:
The audience consists of 3rd-year BSc students, who are mostly people with some
practical experience of writing code. The purpose of the Syllabus is to
manage their expectations and prepare for the examination.

\newpage
\textbf{The reasons why this new course and/or this new syllabus is needed and how it will fit into IU curriculum}:
As far as I understand, modern computer science education is strong in theories
but lacks the connection with practical engineering. In other words, students
have little chance of being taught by those who professionally write code every
day and solve real-life technical problems. Me teaching them software design
may be one of these opportunities: to link their theoretical learning with
the practice.

\newpage
\textbf{The view(s) of learning in your course how learning happens in the course}:
The course is all about problem-based learning. Many aspects of software design
are decomposed into individual problems and solutions are discussed. Also, it
is suggested to students to make their own projects and solve problems there.

\newpage
\textbf{The view(s) of learning assessment in the course}:
The assessment is based on software products, which students create. There are
five criteria which are being assessed: requirements, design, architecture, code,
and the "spirit" of development.
\emph{Formative} evaluation is only performed by TAs, three times during the course
at alpha, beta, and release milestones: students present their software products
and TAs subjectively evaluate them using the criteria define below.
\emph{Summative} evaluation is done by myself at the end of the course and is
based on the evaluations provided by TAs three times during the course:
my decision is also subjective, but preliminary evaluations help students
understand pros and cons of their products.
There is no significant difference between high and low stake assessments in the course,
since all five criteria are balanced: they both are \emph{middle stake} assessments.

\newpage
\textbf{The view(s) of progression in the course}:
At the end of each lecture I'm giving them suggestion of what they may
try to use in their projects. I explain them why these "calls-to-action" may
help them understand software design better. There are few progression
scenarios expected: 1)~from knowing \textbf{how to code} they will progress to knowing
how to explain design decisions in UML, 2)~from UML they will progress to
knowing \textbf{how to use design patterns}, 3)~from design patterns they will progress
to knowing \textbf{how to test} their modules and automate tests, 4)~from tests
they will progress to \textbf{more complex decisions} about data, performance,
formats, and interoperability.

\newpage
\textbf{The view(s) of recycling in the course}:
The course is teaching incremental and interactive programming, and it is also
designed in incremental manner: every few weeks students must present
their products and collect feedback. It is expected that their knowledge
is recycled (refreshed) on each delivery cycle, since they have
to review all layers of their products. They have to go through everything
they know about software design a few times during the course.

\newpage
\textbf{The view(s) of alignment in the course}:
Learning \textbf{objectives}: by the end of the course students are able to design a software component and explain made design decisions.
Learning \textbf{activities}: during the course students are instructed how to design a software and how design decisions can be explained, using different formats and approaches, such as UML, design patterns, RUP/SAD, and so on.
Learning \textbf{assessment}: at the end of the course software products created by students are evaluated to check whether design decisions are sound and well explained.

\newpage
\textbf{The view(s) of course design framework you used/will use to design your course}:
Integrated course design framework is used to design this course.
At initial design phase course objectives were defined.
At intermediate design phase the body of the course was created.
At the final design phase the course was re-evaluated for consistency.

\newpage
\textbf{The view(s) of course evaluation}:
I created a Telegram chat group for all students of the course and asked them
to provide feedback after some lectures. The results collected (in form of anonymous polls)
I used to correct myself and improve future lectures. For example, I gave
more examples of practical software design decisions in response to negative
comments about some of my slides. Another example, I formalized the Syllabus
of the course in response to comments about its vagueness. I also had
an additional synchronization session with TAs in response to complaints
about our disintegration.

\newpage
\textbf{Potential risks in the course and the ways to address them}:
I was doing this course for the first time, that's why there were many risks.
First, I expected myself being wrong at some points given to them.
Second, I anticipated their lack of interest to certain topics inside the course.
Third, I wasn't sure that the topics I cover are aligned with our courses.
In order to mitigate these risks I organized a few workshops with TAs,
who are more knowledgeable in this aspect. They helped me understand the
context where my course is placed. Moreover, they gave me materials
from previous year course of the same title --- it was helpful.


% \section*{Introduction}

% \textbf{Who is the teacher?}
% I'm not a professional teacher and, frankly speaking, I'm doing this course
% as a humble attempt to become one. My background is 25+ years of
% practical software engineering in small startups and large software companies,
% like Huawei, where I'm at the moment a director of an R\&D laboratory focused
% on software quality problems. You may find some lectures I've presented
% at some software conferences on \href{https://www.youtube.com/channel/UCr9qCdqXLm2SU0BIs6d_68Q}{my YouTube channel}.

% \textbf{Why this course?}
% The idea to present this course organically
% came out from cooperation, which has recently started between
% Huawei and Innopolis University. We both realized that the practical experience
% Huawei has gained by writing millions line of code over the last few decades
% may be a valuable contribution to the education provided by the University
% to the next tech generation.

% \textbf{What's the methodology?}
% The learning process in this course is very much \emph{problem-based}:
% each lecture presents a number of key problems software development industry
% has known for years. For example, in the lecture about database design I
% demonstrate that transaction isolation, schema versioning, data distribution, and
% performance are the problems. Then, I explain some solutions which already
% exist and suggest future research directions to find better ones. On top
% of that, the learning is \emph{project-based}, since it's required for the
% students to apply some of the solutions suggested in the projects they are
% making in order to pass the exam at the end of the course.

\newpage
\section*{Course Aims}

Prerequisites to the course (it is expected that a student knows this):

\begin{itemize}
\item How to code
\item How to use Git
\end{itemize}

After the course a student \emph{hopefully} will know:

\begin{itemize}
\item How to manage software requirements
\item How to develop iteratively and incrementally
\item How to think with objects, not procedures
\item How to use design patterns and not use anti-patterns
\item How to draw and share knowledge using UML
\item How to choose and use data formats, e.g. XML or JSON
\item How to choose a database management server
\item How to deploy software continuously
\item How to build distributed software systems
\item How to test software
\item How to measure the quality of software design
\end{itemize}

They will also be able to:

\begin{itemize}
\item Document requirements in SRS and use cases
\item Make key design decisions
\item Explain them in UML
\item Organize repository in GitHub
\item Automate the build and cover it with tests
\end{itemize}

\newpage
\section*{Assessment}

At the end of the course a student receives a \emph{score} of up
to 100 points. The points are given after a \emph{subjective} review
of an open source software product created by the student during the
course (no oral presentation is needed).
Even though the review is subjective, the following
balance has to be maintained (the questions provided below
stand merely as examples and do not constitute the entire scope):

\begin{itemize}
\item {\bfseries\scshape Requirements} (15\%):
  Glossary is in place?
  Stakeholders and their concerns are identified?
  Use cases explain functional requirements?
  Non-functional requirements are documented?
  NFRs are measurable?
\item {\bfseries\scshape Design} (25\%):
  UML diagrams, such as Class, Component, Deployment, and Sequence, are present?
  Design decisions are explained?
  Design patterns are used?
  Traceability between requirements and design elements is visible?
\item {\bfseries\scshape Architecture} (30\%):
  The design is modular?
  The composition of modules makes sense?
  Design elements are cohesive?
  Design elements are decoupled enough?
  The build is automated?
  The delivery pipeline is automated?
\item {\bfseries\scshape Code} (15\%):
  The code is clean enough?
  In-code documentation is present?
  Static analyzers and style checkers are used?
  Unit tests are in place?
  Integration tests are present?
  Is test coverage being measured?
\item {\bfseries\scshape Spirit} (15\%):
  The product is somewhat popular on GitHub (or a similar platform)?
  Issues and pull requests were used during development?
  Commit comments are detailed enough?
  GitHub features are actively used, like releases, actions, etc.?
\end{itemize}

A few versions of the product may be presented for review:
Alpha, Beta, and Final. The scores given to a student
after version reviews don't affect the overall
score given at the end of the course. However, if Alpha
version is not delivered, a student gets a penalty of 10 negative points,
while a missed Beta gives 20 negative points. Thus, if a student
ignores both versions and brings a great product at the end of the course,
he or she gets $100-30=70$ points at most.

The score may be turned into a grade using the following formula:

\begin{itemize}
\item \textbf{A} Excellent: 90+
\item \textbf{B} Good: 75+
\item \textbf{C} Satisfactory: 55+
\item \textbf{D} Poor: 0+
\end{itemize}

\newpage
\section*{Learning Material}

The following books are highly recommended to read (in no particular order):

\begin{multicols}{2}\small\raggedright
Len Bass et al., \emph{Software Architecture in Practice}\\[3pt]
Paul Clements et al., \emph{Documenting Software Architectures: Views and Beyond}\\[3pt]
\nospell{Karl Wiegers} et al., \emph{Software Requirements}\\[3pt]
{\nospell{Alistair Cockburn}}, \emph{Writing Effective Use Cases}\\[3pt]
{\nospell{Steve McConnell}}, \emph{Software Estimation: Demystifying the Black Art}\\[3pt]
{Robert Martin}, \emph{Clean Architecture: A Craftsman's Guide to Software Structure and Design}\\[3pt]
{Steve McConnell}, \emph{Code Complete}\\[3pt]
{Frederick Brooks Jr.}, \emph{Mythical Man-Month, The: Essays on Software Engineering}\\[3pt]
{David Thomas et al.}, \emph{The Pragmatic Programmer: Your Journey To Mastery}\\[3pt]
{Robert C. Martin}, \emph{Clean Code: A Handbook of Agile Software Craftsmanship}\\[3pt]
{\nospell{Grady Booch} et al.}, \emph{Object-Oriented Analysis and Design with Applications}\\[3pt]
{\nospell{Bjarne Stroustrup}}, \emph{Programming: Principles and Practice Using C++}\\[3pt]
{\nospell{Brett McLaughlin} et al.}, \emph{Head First Object-Oriented Analysis and Design: A Brain Friendly Guide to OOA\&D}\\[3pt]
{David West}, \emph{Object Thinking}\\[3pt]
{Eric Evans}, \emph{Domain-Driven Design: Tackling Complexity in the Heart of Software}\\[3pt]
{Yegor Bugayenko}, \emph{Elegant Objects}\\[3pt]
{Michael Feathers}, \emph{Working Effectively with Legacy Code}\\[3pt]
{Martin Fowler}, \emph{Refactoring: Improving the Design of Existing Code}\\[3pt]
{Erich Gamma et al.}, \emph{Design Patterns: Elements of Reusable Object-Oriented Software}\\[3pt]
{Scott Meyers}, \emph{Effective C++: 55 Specific Ways to Improve Your Programs and Designs}\\[3pt]
{\nospell{Elliotte Rusty Harold} et al.}, \emph{XML in a Nutshell, Third Edition}\\[3pt]
{\nospell{Michael James Fitzgerald}}, \emph{Learning XSLT: A Hands-On Introduction to XSLT and XPath}\\[3pt]
{Martin Fowler}, \emph{UML Distilled}\\[3pt]
{\nospell{Anneke Kleppe} et al.}, \emph{MDA Explained: The Model Driven Architecture: Practice and Promise}\\[3pt]
{C.J. Date}, \emph{An Introduction to Database Systems, 8th Edition}\\[3pt]
{\nospell{Pramod Sadalage} et al.}, \emph{NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence}\\[3pt]
{\nospell{Jez Humble} et al.}, \emph{Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation}\\[3pt]
{\nospell{Michael T. Nygard}}, \emph{Release It!: Design and Deploy Production-Ready Software}\\[3pt]
{Leonard Richardson et al.}, \emph{RESTful Web APIs: Services for a Changing World}
\end{multicols}

\end{document}
